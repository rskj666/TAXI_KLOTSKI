# TAXI_KLOTSKI(开心挪挪车)

![开心挪挪车](https://i-blog.csdnimg.cn/blog_migrate/2f734149323988b553454ea807970033.png#pic_center)

## 文件包含

`README.md` 说明解释文档

`TAXI_KLOTSKI(开心挪挪车).pdf`说明解释文档的pdf版本

`开心挪挪车演示视频.mp4` H.264演示视频

`源代码`

​	`源.cpp`代码

​	`*.png`项目运行所需的图片资源

​	`EasyXPng.h` png设置透明背景的头文件



## 功能

### EDIT MODE

- 创建一张初始地图，里面包含了一辆TAXI和各种形状位置不同的小车，彼此不相互碰撞，因为没有任何车辆选中，右侧确认添加和删除为空，且四个方向键均被禁用
- 单击一辆小车(非TAXi)，对应小车会出现白色方框[演示为(0,0)的绿色车]
  - 方向键会解锁对应方向的两个键，确认删除按钮打开
    - 点击方向键会将小车往指定方向移动一格[演示向右后向左]
      - 若出界或者碰到其他车则不会移动
    - 点击删除键会删除这辆小车，并报出提示
    - ==[演示(2,2)的蓝色小车,先向上在向下]==
- 若单击的小车为(TAXI)，其他同上，但是删除键不会打开
- 添加一辆小车[演示为(0,0)的绿色小车]，单击右侧绿色小车按钮，会添加一个被白色斜线标记的绿色小车，此时确认添加按键打开，确认删除按键打开，四个方向均开启
  - 小车初始放在(0,0)的位置上
  - 可以移动这辆小车，不受其他车的限制，但受边界限制[演示随意方向移动]
  - 点击地图的其他区域取消此次添加
  - 点击删除小车取消此次添加
  - [把小车放在刚刚的对应位置]
  - 点击确认添加按钮，如果添加成功则取消斜线框，右侧出现添加的这辆小车的所有信息，代表添加成功
  - 若小车与其他车碰撞，则无法添加，提示报错，保留在添加模式

### ANSWER MODE

​	单击启动汽车华容道自动求解进入解模式

​	刚刚右侧的按键全部隐藏，出现了上一步，下一步和切换至编辑模式三个按键

​	上一步按键禁用

- 单击下一步，图上会出现对应下一步的图像
- 右侧会出现步数信息及路径文字信息
- 此时上一步和下一步均开启(如果有的话)
- [不断点击下一步，直到最后一步]
- 此时下一步被禁用，可以退回上一步进行查看
- 单击右下角编辑模式退回EDIT MODE

[展示一个没有解的情况]

- 单击启动汽车华容道自动求解尝试进入解模式
- 不会进入解模式，会报出没有解的提示

## 特别说明

地图为6*6，索引从(0,0)开始到(5,5)

存储了总共五种车，车左上角的点为标志点

- TAXI 2*1只能左右移动，目标车，初始位置在(0,2),目标位置(4,2)
- RED_CAR 2*1只能左右移动
- BLUE_CAR 1*2只能上下移动
- GREEN_CAR 3*1只能左右移动
- GREY_CAR 1*2只能上下移动

一辆车朝一个方向移动任意距离直到碰到其他车或边界算一步

## 算法分析

整体使用的是A*算法

### 容器

用了`std::set`来存放关闭列表，只有所有车位置都不一样才视作不同的图(即使步数或前置位置不一样)，因为set判断重复的条件`!a<b&&!b<a`     ![image-20250410225100077](C:/Users/yikar/AppData/Roaming/Typora/typora-user-images/image-20250410225100077.png)

![image-20250410225330868](https://rskjyikar666.oss-cn-shanghai.aliyuncs.com/I:/%E5%9B%BE%E5%BA%8A/A/20250410225330929.png)

用了`std::std::priority_queue`来存放模拟小顶堆，每次取出代价最小的结点进行遍历

![image-20250410225745748](https://rskjyikar666.oss-cn-shanghai.aliyuncs.com/I:/%E5%9B%BE%E5%BA%8A/A/20250410225745800.png)

![image-20250410225845054](https://rskjyikar666.oss-cn-shanghai.aliyuncs.com/I:/%E5%9B%BE%E5%BA%8A/A/20250410225845116.png)

代价函数

$F(x)=当前已经走的步数*100+目标车离出库的最短距离*60+这条路上挡路的车数量*30$

用了`std::stack`来存放结果路径，如果没有解则为空，先进的是步数大的

![image-20250410230102426](https://rskjyikar666.oss-cn-shanghai.aliyuncs.com/I:/%E5%9B%BE%E5%BA%8A/A/20250410230102467.png)

### A*算法

![image-20250410230254426](https://rskjyikar666.oss-cn-shanghai.aliyuncs.com/I:/%E5%9B%BE%E5%BA%8A/A/20250410230254538.png)

1. 传入start<MAP>,将其加入开放和关闭列表
2. 每次取出开放列表中代价最小的结点
3. 判断目标车是否可以直接出库，如果是则把每步结果推入`path`并且返回`true`
4. 如果否则直接调用`move_all`函数获得这张图通过朝一个方向移动任一辆车(也就是花一步)可以获得的所有衍生图，存入一个`std::vector`中
5. 对std::vector中所有地图判断是否已经遍历过(利用关闭列表)，如果没有遍历过则同时加入开放和关闭列表
6. 直到遍历结束还没找到解，path中为空且返回`false`
